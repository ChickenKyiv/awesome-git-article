---
id: s5e24
title:
sidebar_label:
---


#### git revert makes a new commit

`git revert` simply creates a new commit that is the opposite of an existing commit.

It leaves the files in the same state as if the commit that has been reverted never existed. For example, consider the following simple example

```
$ cd /tmp/example
$ git init
Initialized empty Git repository in /tmp/example/.git/
$ echo "Initial text" > README.md
$ git add README.md
$ git commit -m "initial commit"
[master (root-commit) 3f7522e] initial commit
 1 file changed, 1 insertion(+)
 create mode 100644 README.md
$ echo "bad update" > README.md
$ git commit -am "bad update"
[master a1b9870] bad update
 1 file changed, 1 insertion(+), 1 deletion(-)
 ```

 In this example the commit history has two commits and the last one is a mistake. Using git revert:

```
 $ git revert HEAD
[master 1db4eeb] Revert "bad update"
 1 file changed, 1 insertion(+), 1 deletion(-)
 ```

There will be 3 commits in the log:

```
$ git log --oneline
1db4eeb Revert "bad update"
a1b9870 bad update
3f7522e initial commit
```
So there is a consistent history of what has happened, yet the files are as if the bad update never occured:
```
cat README.md
Initial text
```

It doesn't matter where in the history the commit to be reverted is (in the above example, the last commit is reverted - any commit can be reverted).

Closing questions
*do you have to do something else after?*

A git revert is just another commit, so e.g. push to the remote so that other users can pull/fetch/merge the changes and you're done.

*Do you have to commit the changes revert made or does revert directly commit to the repo?*

git revert is a commit - there are no extra steps assuming reverting a single commit is what you wanted to do.

*Obviously you'll need to push again and probably announce to the team.*

Indeed - if the remote is in an unstable state - communicating to the rest of the team that they need to pull to get the fix (the reverting commit) would be the right thing to do :).


---  
And - you can revert a revert, where there are several new commits since the revert you're reverting. So revert truly is just a commit of the opposite of the reverted commit. You might, of course, have conflicts ... but that's a different story.

Some people love to use revert with `-n` or `--no-commit` flag. but it's matter of taste actually.
I prefer to have a commit, that can notify everyone what is going on.



---

If your changes have already been pushed to a **public**, **shared remote**, and you want to revert all commits between `HEAD` and ``<sha-id>``, then you can pass a commit range to `git revert`,

`git revert 56e05f..HEAD`
and it will revert all commits between `56e05f` and `HEAD` (excluding the start point of the range, `56e05f`).

**Note that if you're reverting a few hundred commits, this could take a while because you have to commit each revert individually.**



What **git-revert** does is create a commit which undoes changes made in a given commit, creating a commit which is reverse (well, reciprocal) of a given commit. Therefore

`git revert <SHA-1>``
should and does work.

If you want to rewind back to a specified commit, and you can do this because this part of history was not yet published, you need to use git-reset, not git-revert:

`git reset --hard <SHA-1>``
(Note that ``--hard` would make you lose any non-committed changes in the working directory).


**In the case that you're history has already been pushed to a remote before you did the hard reset, you would need to force push the newly reset branch with `git push -f`, but **Be Warned** that this could possibly unintentionally delete other users' commits, and if not delete new commits, then it will force other users to resynchronize their work with the reset branch, so make sure this is OK with your collaborators first.**
